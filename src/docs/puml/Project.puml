@startuml diagram
!include ../style/commons.style

package com.affinitynow.app {
    package model {
        class User {
            - id: long
            - pseudo: string
            - knowledges: Map<String, Knowledge>
            + User(name: string)
            + getPseudo(): string
            + setPseudo(): void
            + getTopic(): string
            + setTopic(): void
            + getKnowledge(): Map<String, Knowledge>
            + equals(user: User): boolean
            + hashcode(): integer
            + toString(): string
        }

        class Topic {
            - id: long
            - Name: string
            + this(Name: string)
            + getName(): string
            + setName(): void
        }

        class Knowledge {
            - topic: Topic
            - level: Level
            + topic(): Topic
            + Level(topic: Topic): Level
        }

        enum Level {
            ONE, TWO, THREE, FOUR, FIVE
        }
    }

    package user {
        package controler {
            class UserControler {
                - userService: UserService
                - userRepository: UserRepository
                + createNewUserWithKnowledge(dto: UserDto): UserDto, POST/user/unowledges
                + getUserMatchingListById(id: long, strategyName:string) , GET/user/{id}/match/{strategyName}
            }
            class TopicControler {
                - topicRepository: TopicRepository
                + getTopics(): List<TopicDto>, GET/topic
            }
        }

        package service {
            class UserService {
                - matchingStrategy: Map<String, Matching>
                + knowledges(user: User): Stream<Knowledge>
                + know(topic: Topic, user:User): boolean 
                + Level(topic: Topic, user: User): Optional<Level>
                + matching(strategyName: string, user: User, matchingUser: User)
            }
            
            interface Matching<T> {
                + match(user1: User, user2: User): Optional<IMatchResult<T>>
            }

            abstract class ScoreMatcher<T> implements Matching{
                match(u:User, mu:User): Optional<IMatchResult<T>>
            }

            abstract class SeekedTopicMatcher<T> implements Matching{
                match(u:User, mu:User): Optional<IMatchResult<T>>
            }

            class DoubleSeekedTopicMatcher<Double> extends SeekedTopicMatcher {
                match(u:User, mu:User): Optional<IMatchResult<Double>>
            }
            
            class BooleanScoreMatcher<Boolean> extends ScoreMatcher {
                + match(user1: User, user2: User): MatchResult
            }

            class DoubleScoreMatcher<Double> extends ScoreMatcher {
                + match(user1: User, user2: User): IMatchResult
            }

            interface IMatchResult<T> extends Comparable{
                + result(): T
                + user(): User
                + mUser(): User
                + qualite(): double
                + default compareTo(m: IMatchResult<T>): int
            }

            class BooleanMatchResult<Boolean> implements IMatchResult{
                - resultat: boolean
                - user: User
                - mUser: USer
                + resultat(): boolean
                + user(): User
                + mUser(): User
                + qualite(): double
            }

            class DoubleMatchResult<Double> implements IMatchResult{
                + resultat: double
                - user: User
                - mUser: USer
                + resultat(): double
                + user(): User
                + mUser(): User
                + qualite(): double
            }
        }

        package dto {
            class UserDto {
                - id: long
                - pseudo: string
                - Knowledges: Map<string, Knowledge>
                + getId(): long
                + setId(id: Long): UserDto
                + getPseudo(): string
                + setPseudo(pseudo: string): UserDto
                + getPseudo(): string
                + setKnowledges(pseudo: string): UserDto
                + addKnowledge(name: string, Knowledge: Knowledge)


            }
        }

        package repository {
            class UserRepository {}
        }
    }
}

UserService *--> "1" Matching
UserControler --> UserService: "uses"
UserService --> UserRepository: "uses"
UserRepository --> User: "uses"
Knowledge *--> "1" Topic
Knowledge *--> "1" Level
User *--> "*" Knowledge: "Knowledge"
Matching --> IMatchResult: "uses"
@enduml