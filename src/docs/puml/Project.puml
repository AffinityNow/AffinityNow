@startuml diagram
!include ../style/commons.style

package com.affinitynow.app {
    package model {
        class User {
            - id: long
            - pseudo: string
            - likedKnowledges: Map<String, Knowledge>
            - seekedKnowledges: Map<String, Knowledge>
            + User(name: string)
            + getPseudo(): string
            + setPseudo(): void
            + getTopic(): string
            + setTopic(): void
            + getLikedKnowledge(knowledges: Map<String, Knowledge>): Map<String, Knowledge>
            + setLikedKnowledges(): void
            + getSeekedKnowledges(knowledges: Map<String, Knowledge>): Map<String, Knowledge>
            + setSeekedKnowledges(): void
            + equals(user: User): boolean
            + hashcode(): integer
            + toString(): string
        }

        class Topic {
            - id: long
            - Name: string
            + this(Name: string)
            + getName(): string
            + setName(): void
        }

        class Knowledge {
            - topic: Topic
            - level: Level
            + topic(): Topic
            + Level(topic: Topic): Level
        }

        enum Level {
            ONE, TWO, THREE, FOUR, FIVE
        }
    }

    package user {
        package controler {
            class UserControler {
                - userService: UserService
                - userRepository: UserRepository
                + createNewUserWithKnowledge(dto: UserDto): UserDto, POST/user/unowledges
                + getUserMatcherListById(id: long, strategyName:string) , GET/user/{id}/match/{strategyName}
            }
        }

        package service {
            class UserService {
                - matcherStrategy: Map<String, Matcher>
                + knowledges(user: User): Stream<Knowledge>
                + know(topic: Topic, user:User): boolean 
                + level(topic: Topic, user: User): Optional<Level>
                + match(strategyName: string, user: User, MatcherUser: User)
            }

            package matcher {
                interface Matcher {
                    + match(user1: User, user2: User): Optional<IMatchResult>
                    + calculateQuality(user: User, user: matchingUser, intersection: Set<Knowledge>);
                }

                interface ScoreMatcher extends Matcher{}

                interface SeekedTopicMatcher extends Matcher{}

                class DoubleSeekedTopicMatcher implements SeekedTopicMatcher {
                    + match(user1: User, user2: User): IMatchResult
                    + calculateQuality(user: User, user: matchingUser, intersection: Set<Knowledge>);
                }
                
                class BooleanScoreMatcher implements ScoreMatcher {
                    + match(user1: User, user2: User): IMatchResult
                    + calculateQuality(user: User, user: matchingUser, intersection: Set<Knowledge>);
                }

                class DoubleScoreMatcher implements ScoreMatcher {
                    + match(user1: User, user2: User): IMatchResult
                    + calculateQuality(user: User, user: matchingUser, intersection: Set<Knowledge>);
                }

                interface IMatchResult<T> extends java.lang.Comparable{
                    + result(): T
                    + user(): User
                    + mUser(): User
                    + qualite(): double
                    + commonTopicsBetweenUsers(): set<Knowledge>
                }

                abstract class AbstractMatchResult<T> implements IMatchResult {
                    - user: User
                    - mUser: User
                    - commonTopics: set<Knowledge>
                    - quality: double
                    ~ this(commonTopics: set<Knowledge>, user: User, mUser: User)
                    + user(): User
                    + mUser(): User
                    + commonTopicsBetweenUsers(): set<Knowledge>
                    + setQuality(quality: double)
                    + qualite(): double
                }

                class BooleanMatchResult<Boolean> extends AbstractMatchResult{
                    - resultat: boolean
                    ~ this(commonTopics: set<Knowledge>, user: User, mUser: User, resultat: boolean)
                    + resultat(): boolean
                    + compareTo(o: IMatchResult<T>): integer
                }

                class DoubleMatchResult<Double> extends AbstractMatchResult{
                    - resultat: double
                    ~ this(commonTopics: set<Knowledge>, user: User, mUser: User, resultat: double)
                    + resultat(): double
                    + compareTo(o: IMatchResult<T>): integer
                }
            }
        }

        package dto {
            class UserDto {
                - id: long
                - pseudo: string
                - Knowledges: Map<string, Knowledge>
                + getId(): long
                + setId(id: Long): UserDto
                + getPseudo(): string
                + setPseudo(pseudo: string): UserDto
                + setKnowledges(pseudo: string): UserDto
                + addKnowledge(name: string, Knowledge: Knowledge)
            }
        }

        package repository {
            class UserRepository {}
        }
    }

    namespace topic {
        namespace controler {
            class TopicControler {
                - topicRepository: TopicRepository
                + getTopics(): List<TopicDto>, GET/topic
            }
        }

        namespace service {
        }

        namespace dto {
            class TopicDto {
                - id: long
                - name: string
                + getId(): long
                + setId(id: Long): TopicDto
                + getName(): string
                + setName(pseudo: string): TopicDto
            }
        }

        namespace repository {
            class TopicRepository {}
        }
    }
}

UserService *--> "*" Matcher
UserControler --> UserService: "uses"
UserService --> UserRepository: "uses"
UserRepository --> User: "uses"
Knowledge *--> "1" Topic
Knowledge *--> "1" Level
User *--> "*" Knowledge: "liked knowledge"
User *--> "*" Knowledge: "seeked knowledge"
Matcher --> IMatchResult: "uses"
@enduml